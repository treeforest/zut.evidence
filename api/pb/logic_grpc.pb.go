// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.7
// source: logic.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LogicClient is the client API for Logic service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogicClient interface {
	// ApplyKYC 申请KYC认证
	ApplyKYC(ctx context.Context, in *ApplyKYCReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Issue 发布凭证
	Issue(ctx context.Context, in *IssueReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetIssued 获取已发布凭证列表
	GetIssued(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetIssuedReply, error)
	// RevokeIssued 撤销已发布凭证
	RevokeIssued(ctx context.Context, in *RevokeIssuedReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetIssuerList 获取凭证发布方列表
	GetIssuerList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetIssuerListReply, error)
	// ChallengeSend 发起挑战
	ChallengeSend(ctx context.Context, in *ChallengeSendReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ChallengeReply 回复挑战
	ChallengeReply(ctx context.Context, in *ChallengeReplyReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ChallengeSent 获取用户发起的挑战
	ChallengeSent(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ChallengeSentReply, error)
	// ChallengeDoing 获取待回复的挑战
	ChallengeDoing(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ChallengeDoingReply, error)
	// ChallengeDone 获取已处理的挑战
	ChallengeDone(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ChallengeDoneReply, error)
	// Apply 申请凭证
	Apply(ctx context.Context, in *ApplyReq, opts ...grpc.CallOption) (*ApplyReply, error)
	// ApplyDoing 获取申请结果：审核中
	ApplyDoing(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ApplyDoingReply, error)
	// ApplyDone 获取申请结果：审核成功
	ApplyDone(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ApplyDoneReply, error)
	// ApplyFailed 获取申请结果：审核失败
	ApplyFailed(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ApplyFailedReply, error)
	// ApplyCount 获取申请的个数
	ApplyCount(ctx context.Context, in *ApplyCountReq, opts ...grpc.CallOption) (*ApplyCountReply, error)
	// Audit 发行人审核申请
	Audit(ctx context.Context, in *AuditReq, opts ...grpc.CallOption) (*AuditReply, error)
	// AuditCount 获取待审核个数
	AuditCount(ctx context.Context, in *AuditCountReq, opts ...grpc.CallOption) (*AuditCountReply, error)
	// AuditDoing 发行人获取待审核的申请
	AuditDoing(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AuditDoingReply, error)
	// AuditFailed 发行人获取已审核失败的条目
	AuditFailed(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AuditFailedReply, error)
	// AuditDone 发行人获取已审核成功的条目
	AuditDone(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AuditDoneReply, error)
}

type logicClient struct {
	cc grpc.ClientConnInterface
}

func NewLogicClient(cc grpc.ClientConnInterface) LogicClient {
	return &logicClient{cc}
}

func (c *logicClient) ApplyKYC(ctx context.Context, in *ApplyKYCReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/Logic/ApplyKYC", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) Issue(ctx context.Context, in *IssueReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/Logic/Issue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) GetIssued(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetIssuedReply, error) {
	out := new(GetIssuedReply)
	err := c.cc.Invoke(ctx, "/Logic/GetIssued", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) RevokeIssued(ctx context.Context, in *RevokeIssuedReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/Logic/RevokeIssued", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) GetIssuerList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetIssuerListReply, error) {
	out := new(GetIssuerListReply)
	err := c.cc.Invoke(ctx, "/Logic/GetIssuerList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) ChallengeSend(ctx context.Context, in *ChallengeSendReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/Logic/ChallengeSend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) ChallengeReply(ctx context.Context, in *ChallengeReplyReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/Logic/ChallengeReply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) ChallengeSent(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ChallengeSentReply, error) {
	out := new(ChallengeSentReply)
	err := c.cc.Invoke(ctx, "/Logic/ChallengeSent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) ChallengeDoing(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ChallengeDoingReply, error) {
	out := new(ChallengeDoingReply)
	err := c.cc.Invoke(ctx, "/Logic/ChallengeDoing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) ChallengeDone(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ChallengeDoneReply, error) {
	out := new(ChallengeDoneReply)
	err := c.cc.Invoke(ctx, "/Logic/ChallengeDone", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) Apply(ctx context.Context, in *ApplyReq, opts ...grpc.CallOption) (*ApplyReply, error) {
	out := new(ApplyReply)
	err := c.cc.Invoke(ctx, "/Logic/Apply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) ApplyDoing(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ApplyDoingReply, error) {
	out := new(ApplyDoingReply)
	err := c.cc.Invoke(ctx, "/Logic/ApplyDoing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) ApplyDone(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ApplyDoneReply, error) {
	out := new(ApplyDoneReply)
	err := c.cc.Invoke(ctx, "/Logic/ApplyDone", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) ApplyFailed(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ApplyFailedReply, error) {
	out := new(ApplyFailedReply)
	err := c.cc.Invoke(ctx, "/Logic/ApplyFailed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) ApplyCount(ctx context.Context, in *ApplyCountReq, opts ...grpc.CallOption) (*ApplyCountReply, error) {
	out := new(ApplyCountReply)
	err := c.cc.Invoke(ctx, "/Logic/ApplyCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) Audit(ctx context.Context, in *AuditReq, opts ...grpc.CallOption) (*AuditReply, error) {
	out := new(AuditReply)
	err := c.cc.Invoke(ctx, "/Logic/Audit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) AuditCount(ctx context.Context, in *AuditCountReq, opts ...grpc.CallOption) (*AuditCountReply, error) {
	out := new(AuditCountReply)
	err := c.cc.Invoke(ctx, "/Logic/AuditCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) AuditDoing(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AuditDoingReply, error) {
	out := new(AuditDoingReply)
	err := c.cc.Invoke(ctx, "/Logic/AuditDoing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) AuditFailed(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AuditFailedReply, error) {
	out := new(AuditFailedReply)
	err := c.cc.Invoke(ctx, "/Logic/AuditFailed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicClient) AuditDone(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AuditDoneReply, error) {
	out := new(AuditDoneReply)
	err := c.cc.Invoke(ctx, "/Logic/AuditDone", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LogicServer is the server API for Logic service.
// All implementations must embed UnimplementedLogicServer
// for forward compatibility
type LogicServer interface {
	// ApplyKYC 申请KYC认证
	ApplyKYC(context.Context, *ApplyKYCReq) (*emptypb.Empty, error)
	// Issue 发布凭证
	Issue(context.Context, *IssueReq) (*emptypb.Empty, error)
	// GetIssued 获取已发布凭证列表
	GetIssued(context.Context, *emptypb.Empty) (*GetIssuedReply, error)
	// RevokeIssued 撤销已发布凭证
	RevokeIssued(context.Context, *RevokeIssuedReq) (*emptypb.Empty, error)
	// GetIssuerList 获取凭证发布方列表
	GetIssuerList(context.Context, *emptypb.Empty) (*GetIssuerListReply, error)
	// ChallengeSend 发起挑战
	ChallengeSend(context.Context, *ChallengeSendReq) (*emptypb.Empty, error)
	// ChallengeReply 回复挑战
	ChallengeReply(context.Context, *ChallengeReplyReq) (*emptypb.Empty, error)
	// ChallengeSent 获取用户发起的挑战
	ChallengeSent(context.Context, *emptypb.Empty) (*ChallengeSentReply, error)
	// ChallengeDoing 获取待回复的挑战
	ChallengeDoing(context.Context, *emptypb.Empty) (*ChallengeDoingReply, error)
	// ChallengeDone 获取已处理的挑战
	ChallengeDone(context.Context, *emptypb.Empty) (*ChallengeDoneReply, error)
	// Apply 申请凭证
	Apply(context.Context, *ApplyReq) (*ApplyReply, error)
	// ApplyDoing 获取申请结果：审核中
	ApplyDoing(context.Context, *emptypb.Empty) (*ApplyDoingReply, error)
	// ApplyDone 获取申请结果：审核成功
	ApplyDone(context.Context, *emptypb.Empty) (*ApplyDoneReply, error)
	// ApplyFailed 获取申请结果：审核失败
	ApplyFailed(context.Context, *emptypb.Empty) (*ApplyFailedReply, error)
	// ApplyCount 获取申请的个数
	ApplyCount(context.Context, *ApplyCountReq) (*ApplyCountReply, error)
	// Audit 发行人审核申请
	Audit(context.Context, *AuditReq) (*AuditReply, error)
	// AuditCount 获取待审核个数
	AuditCount(context.Context, *AuditCountReq) (*AuditCountReply, error)
	// AuditDoing 发行人获取待审核的申请
	AuditDoing(context.Context, *emptypb.Empty) (*AuditDoingReply, error)
	// AuditFailed 发行人获取已审核失败的条目
	AuditFailed(context.Context, *emptypb.Empty) (*AuditFailedReply, error)
	// AuditDone 发行人获取已审核成功的条目
	AuditDone(context.Context, *emptypb.Empty) (*AuditDoneReply, error)
	mustEmbedUnimplementedLogicServer()
}

// UnimplementedLogicServer must be embedded to have forward compatible implementations.
type UnimplementedLogicServer struct {
}

func (UnimplementedLogicServer) ApplyKYC(context.Context, *ApplyKYCReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyKYC not implemented")
}
func (UnimplementedLogicServer) Issue(context.Context, *IssueReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Issue not implemented")
}
func (UnimplementedLogicServer) GetIssued(context.Context, *emptypb.Empty) (*GetIssuedReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIssued not implemented")
}
func (UnimplementedLogicServer) RevokeIssued(context.Context, *RevokeIssuedReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeIssued not implemented")
}
func (UnimplementedLogicServer) GetIssuerList(context.Context, *emptypb.Empty) (*GetIssuerListReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIssuerList not implemented")
}
func (UnimplementedLogicServer) ChallengeSend(context.Context, *ChallengeSendReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengeSend not implemented")
}
func (UnimplementedLogicServer) ChallengeReply(context.Context, *ChallengeReplyReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengeReply not implemented")
}
func (UnimplementedLogicServer) ChallengeSent(context.Context, *emptypb.Empty) (*ChallengeSentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengeSent not implemented")
}
func (UnimplementedLogicServer) ChallengeDoing(context.Context, *emptypb.Empty) (*ChallengeDoingReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengeDoing not implemented")
}
func (UnimplementedLogicServer) ChallengeDone(context.Context, *emptypb.Empty) (*ChallengeDoneReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengeDone not implemented")
}
func (UnimplementedLogicServer) Apply(context.Context, *ApplyReq) (*ApplyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Apply not implemented")
}
func (UnimplementedLogicServer) ApplyDoing(context.Context, *emptypb.Empty) (*ApplyDoingReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyDoing not implemented")
}
func (UnimplementedLogicServer) ApplyDone(context.Context, *emptypb.Empty) (*ApplyDoneReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyDone not implemented")
}
func (UnimplementedLogicServer) ApplyFailed(context.Context, *emptypb.Empty) (*ApplyFailedReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyFailed not implemented")
}
func (UnimplementedLogicServer) ApplyCount(context.Context, *ApplyCountReq) (*ApplyCountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyCount not implemented")
}
func (UnimplementedLogicServer) Audit(context.Context, *AuditReq) (*AuditReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Audit not implemented")
}
func (UnimplementedLogicServer) AuditCount(context.Context, *AuditCountReq) (*AuditCountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuditCount not implemented")
}
func (UnimplementedLogicServer) AuditDoing(context.Context, *emptypb.Empty) (*AuditDoingReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuditDoing not implemented")
}
func (UnimplementedLogicServer) AuditFailed(context.Context, *emptypb.Empty) (*AuditFailedReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuditFailed not implemented")
}
func (UnimplementedLogicServer) AuditDone(context.Context, *emptypb.Empty) (*AuditDoneReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuditDone not implemented")
}
func (UnimplementedLogicServer) mustEmbedUnimplementedLogicServer() {}

// UnsafeLogicServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogicServer will
// result in compilation errors.
type UnsafeLogicServer interface {
	mustEmbedUnimplementedLogicServer()
}

func RegisterLogicServer(s grpc.ServiceRegistrar, srv LogicServer) {
	s.RegisterService(&Logic_ServiceDesc, srv)
}

func _Logic_ApplyKYC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyKYCReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).ApplyKYC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/ApplyKYC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).ApplyKYC(ctx, req.(*ApplyKYCReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_Issue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IssueReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).Issue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/Issue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).Issue(ctx, req.(*IssueReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_GetIssued_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).GetIssued(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/GetIssued",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).GetIssued(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_RevokeIssued_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeIssuedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).RevokeIssued(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/RevokeIssued",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).RevokeIssued(ctx, req.(*RevokeIssuedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_GetIssuerList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).GetIssuerList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/GetIssuerList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).GetIssuerList(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_ChallengeSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChallengeSendReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).ChallengeSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/ChallengeSend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).ChallengeSend(ctx, req.(*ChallengeSendReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_ChallengeReply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChallengeReplyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).ChallengeReply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/ChallengeReply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).ChallengeReply(ctx, req.(*ChallengeReplyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_ChallengeSent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).ChallengeSent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/ChallengeSent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).ChallengeSent(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_ChallengeDoing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).ChallengeDoing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/ChallengeDoing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).ChallengeDoing(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_ChallengeDone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).ChallengeDone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/ChallengeDone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).ChallengeDone(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_Apply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).Apply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/Apply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).Apply(ctx, req.(*ApplyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_ApplyDoing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).ApplyDoing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/ApplyDoing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).ApplyDoing(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_ApplyDone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).ApplyDone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/ApplyDone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).ApplyDone(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_ApplyFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).ApplyFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/ApplyFailed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).ApplyFailed(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_ApplyCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).ApplyCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/ApplyCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).ApplyCount(ctx, req.(*ApplyCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_Audit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuditReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).Audit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/Audit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).Audit(ctx, req.(*AuditReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_AuditCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuditCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).AuditCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/AuditCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).AuditCount(ctx, req.(*AuditCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_AuditDoing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).AuditDoing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/AuditDoing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).AuditDoing(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_AuditFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).AuditFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/AuditFailed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).AuditFailed(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logic_AuditDone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServer).AuditDone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Logic/AuditDone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServer).AuditDone(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Logic_ServiceDesc is the grpc.ServiceDesc for Logic service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Logic_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Logic",
	HandlerType: (*LogicServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ApplyKYC",
			Handler:    _Logic_ApplyKYC_Handler,
		},
		{
			MethodName: "Issue",
			Handler:    _Logic_Issue_Handler,
		},
		{
			MethodName: "GetIssued",
			Handler:    _Logic_GetIssued_Handler,
		},
		{
			MethodName: "RevokeIssued",
			Handler:    _Logic_RevokeIssued_Handler,
		},
		{
			MethodName: "GetIssuerList",
			Handler:    _Logic_GetIssuerList_Handler,
		},
		{
			MethodName: "ChallengeSend",
			Handler:    _Logic_ChallengeSend_Handler,
		},
		{
			MethodName: "ChallengeReply",
			Handler:    _Logic_ChallengeReply_Handler,
		},
		{
			MethodName: "ChallengeSent",
			Handler:    _Logic_ChallengeSent_Handler,
		},
		{
			MethodName: "ChallengeDoing",
			Handler:    _Logic_ChallengeDoing_Handler,
		},
		{
			MethodName: "ChallengeDone",
			Handler:    _Logic_ChallengeDone_Handler,
		},
		{
			MethodName: "Apply",
			Handler:    _Logic_Apply_Handler,
		},
		{
			MethodName: "ApplyDoing",
			Handler:    _Logic_ApplyDoing_Handler,
		},
		{
			MethodName: "ApplyDone",
			Handler:    _Logic_ApplyDone_Handler,
		},
		{
			MethodName: "ApplyFailed",
			Handler:    _Logic_ApplyFailed_Handler,
		},
		{
			MethodName: "ApplyCount",
			Handler:    _Logic_ApplyCount_Handler,
		},
		{
			MethodName: "Audit",
			Handler:    _Logic_Audit_Handler,
		},
		{
			MethodName: "AuditCount",
			Handler:    _Logic_AuditCount_Handler,
		},
		{
			MethodName: "AuditDoing",
			Handler:    _Logic_AuditDoing_Handler,
		},
		{
			MethodName: "AuditFailed",
			Handler:    _Logic_AuditFailed_Handler,
		},
		{
			MethodName: "AuditDone",
			Handler:    _Logic_AuditDone_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "logic.proto",
}
